init и destroy
init: код, который должен выполниться “после сборки” бина — проверка настроек, открытие ресурсов, прогрев кэша, вывод “готов к работе”. Задаётся либо в @Bean(initMethod="..."), либо через @PostConstruct в самом классе.

destroy: код “перед убийством” бина — закрыть соединения, освободить ресурсы, сохранить состояние. Задаётся в @Bean(destroyMethod="...") или через @PreDestroy. Контекст должен быть корректно закрыт (try-with-resources или close()), чтобы destroy отработал.

Для чего аннотации в Java и в Spring
В Java: аннотации — метаданные для кода; ими помечают классы/методы/поля, чтобы инструменты и рантайм могли применять поведение (например, @Override, @Deprecated, @Nullable).

В Spring: аннотации описывают конфигурацию и связывание бинов без XML — помечают компоненты (@Component/@Service/@Repository/@Controller), точки внедрения (@Autowired/@Value), конфигурацию (@Configuration/@Bean), области действия (@Scope), профили (@Profile) и т.д.

Как определить компоненты и связать их аннотациями
Пометить классы как компоненты: @Component, @Service, @Repository — это регистрирует их как бины.

Включить сканирование пакетов: @ComponentScan в конфигурации — контейнер найдёт и зарегистрирует помеченные классы.

Внедрение зависимостей: конструкторная инъекция (рекомендуется) через @Autowired на конструкторе или просто один публичный конструктор; поля/сеттеры — через @Autowired (по необходимости). Значения из настроек — @Value("${key}").

Для чего @Qualifier
Когда есть несколько бинов одного типа, @Qualifier уточняет, какой именно внедрять: по имени бина или кастомной метке.

Пример: есть два Contents (bookContents, toyContents). В конструкторе Box можно написать параметр Contents и добавить @Qualifier("bookContents"), чтобы получить нужную реализацию.

Как конфигурировать контекст Java‑кодом
Создать класс конфигурации: @Configuration.

Указать сканирование: @ComponentScan("com.example...") — автоматически найдёт @Component‑классы.

Подключить свойства: @PropertySource("classpath:app.properties") и бин PropertySourcesPlaceholderConfigurer (часто static @Bean) — чтобы работал @Value.

Объявлять бины фабричными методами: методы с @Bean возвращают объекты; можно указать initMethod/destroyMethod, @Scope, @Qualifier на аргументах, получать в аргументах метода уже готовые зависимости.

Создать контекст и работать: new AnnotationConfigApplicationContext(AppConfig.class); getBean(...) или конструкторная инъекция в других бинах.



Базовые для конфигурации

@Configuration — класс с Java‑конфигурацией бинов.

@Bean — фабричный метод: вернуть объект, который станет бином; можно указать initMethod/destroyMethod/@Scope.

@ComponentScan — включить сканирование пакетов на наличие компонентов.

@PropertySource — подключить .properties в контекст.

@Import — подтянуть другие классы‑конфигурации.

Стереотипы компонентов

@Component — общий “я — бин” для любого класса.

@Service — сервисный слой (бизнес‑логика), семантический подтип @Component.

@Repository — слой доступа к данным; включает преобразование исключений в DataAccessException.

@Controller — MVC‑контроллер (шаблоны/виды).

@RestController — @Controller + @ResponseBody по умолчанию для REST.

Внедрение зависимостей и значения

@Autowired — внедрение зависимости (конструктор/сеттер/поле).

@Qualifier — выбрать конкретный бин среди нескольких одного типа.

@Value — подставить простое значение, в т.ч. из properties: ${key}.

@Scope — область действия бина: singleton, prototype, request, session, application, websocket.

Жизненный цикл

@PostConstruct — метод вызывается после создания и внедрения зависимостей.

@PreDestroy — метод вызывается перед уничтожением бина.

Профили и условия

@Profile — активировать бин/конфигурацию для заданных профилей (dev, prod и т.п.).

@Conditional — создавать бин при выполнении условия (например, если есть класс/свойство/среда).